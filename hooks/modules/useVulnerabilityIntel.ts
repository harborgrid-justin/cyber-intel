
import { useState, useEffect, useMemo, useCallback } from 'react';
import { threatData } from '../../services/dataLayer';
import { useDataStore } from '../useDataStore';
import { VulnerabilityLogic } from '../../services/logic/VulnerabilityLogic';
import { VulnerabilityScan, View } from '../../types';
import { useIsMounted } from '../useIsMounted';

export const useVulnerabilityIntel = () => {
  const isMounted = useIsMounted();
  const modules = useMemo(() => threatData.getModulesForView(View.VULNERABILITIES), []);
  const [activeModule, setActiveModule] = useState(modules[0]);
  const [activeScan, setActiveScan] = useState<VulnerabilityScan | null>(null);

  // Subscriptions
  const vulns = useDataStore(() => threatData.getVulnerabilities());
  const assets = useDataStore(() => threatData.getSystemNodes());
  const patchStatus = useDataStore(() => threatData.getPatchStatus());
  const scanners = useDataStore(() => threatData.getScannerStatus());
  const vendorFeeds = useDataStore(() => threatData.getVendorFeedItems());

  // Async Logic State
  const [zeroDayImpact, setZeroDayImpact] = useState({ affectedAssets: 0, mitigationRate: 0 });
  const [correlatedFeeds, setCorrelatedFeeds] = useState<any[]>([]);

  useEffect(() => {
    let cancel = false;
    const fetchAsyncData = async () => {
      try {
        const impact = await VulnerabilityLogic.assessZeroDayImpact(vulns, assets);
        if (!cancel && isMounted()) setZeroDayImpact(impact);
        
        const feeds = await VulnerabilityLogic.correlateVendorAdvisories(vendorFeeds, assets);
        if (!cancel && isMounted()) setCorrelatedFeeds(feeds);
      } catch (e) {
        console.error("Vulnerability Logic Error", e);
      }
    };
    fetchAsyncData();
    return () => { cancel = true; };
  }, [vulns, assets, vendorFeeds, isMounted]);

  const handlePatch = useCallback((id: string) => {
    threatData.updateVulnerabilityStatus(id, 'PATCHED');
  }, []);

  const handleRunScan = useCallback(() => {
    const newScan: VulnerabilityScan = {
      id: `SCAN-${Date.now()}`,
      target: 'Full Infrastructure',
      status: 'RUNNING',
      findings: 0,
      progress: 0,
      startTime: new Date().toLocaleTimeString()
    };
    setActiveScan(newScan);
    
    // Simulate Scan Progress safely
    let progress = 0;
    const interval = setInterval(() => {
      if (!isMounted()) { clearInterval(interval); return; }
      progress += 10;
      if (progress >= 100) {
        clearInterval(interval);
        setActiveScan(prev => prev ? { ...prev, status: 'COMPLETED', progress: 100, findings: 3 } : null);
        setTimeout(() => isMounted() && setActiveScan(null), 3000); 
      } else {
        setActiveScan(prev => prev ? { ...prev, progress } : null);
      }
    }, 500);
  }, [isMounted]);

  const criticalCves = useMemo(() => vulns.filter(c => c.score >= 9.0), [vulns]);
  const zeroDays = useMemo(() => vulns.filter(c => c.zeroDay), [vulns]);
  const exploitedCves = useMemo(() => vulns.filter(c => c.exploited), [vulns]);
  const scannerHealth = useMemo(() => VulnerabilityLogic.validateScannerHealth(scanners), [scanners]);

  return {
    modules, activeModule, setActiveModule,
    activeScan, handleRunScan,
    vulns, assets, patchStatus, scanners, vendorFeeds,
    zeroDayImpact, correlatedFeeds,
    criticalCves, zeroDays, exploitedCves, scannerHealth,
    handlePatch
  };
};
