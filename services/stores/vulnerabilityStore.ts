
import { Vulnerability } from '../../types';
import { BaseStore } from './baseStore';
import { DatabaseAdapter } from '../dbAdapter';
import { DataMapper } from '../dataMapper';

export class VulnerabilityStore extends BaseStore<Vulnerability> {
  constructor(key: string, initialData: Vulnerability[], adapter: DatabaseAdapter, mapper?: DataMapper<Vulnerability>) {
    super(key, initialData, adapter, mapper);
  }

  updateStatus(id: string, status: Vulnerability['status']) {
    const res = this.getById(id);
    if (res.success && res.data) {
      const vuln = res.data;
      vuln.status = status;
      this.update(vuln);
    }
  }

  addScanFindings(findings: Vulnerability[]) {
    findings.forEach(f => {
      const res = this.getById(f.id);
      if (res.success && res.data) {
        const existing = res.data;
        // Update existing if new scan shows it's still active/changed
        this.update({ ...existing, ...f, status: existing.status === 'PATCHED' ? 'NEW' : existing.status });
      } else {
        this.add(f);
      }
    });
  }

  getMsgByVendor(vendor: string): Vulnerability[] {
    return this.items.filter(v => v.vendor.toLowerCase() === vendor.toLowerCase());
  }

  getCriticalUnpatched(): Vulnerability[] {
    return this.items.filter(v => v.score >= 9.0 && v.status !== 'PATCHED');
  }
}
