
import { Vulnerability } from '../../types';
import { BaseStore } from './baseStore';
import { DatabaseAdapter } from '../dbAdapter';
import { DataMapper } from '../dataMapper';
import { Result, ok, fail, AppError } from '../../types/result';

export class VulnerabilityStore extends BaseStore<Vulnerability> {
  constructor(key: string, initialData: Vulnerability[], adapter: DatabaseAdapter, mapper?: DataMapper<Vulnerability>) {
    super(key, initialData, adapter, mapper);
  }

  updateStatus(id: string, status: Vulnerability['status']): Result<void> {
    try {
      const res = this.getById(id);
      if (res.success && res.data) {
        const vuln = res.data;
        vuln.status = status;
        return this.update(vuln);
      }
      return fail(new AppError('Vulnerability not found', 'VALIDATION'));
    } catch (e) {
      return fail(new AppError('Failed to update vulnerability status', 'SYSTEM', { originalError: e }));
    }
  }

  addScanFindings(findings: Vulnerability[]): Result<void> {
    try {
      findings.forEach(f => {
        const res = this.getById(f.id);
        if (res.success && res.data) {
          const existing = res.data;
          // Update existing if new scan shows it's still active/changed
          this.update({ ...existing, ...f, status: existing.status === 'PATCHED' ? 'NEW' : existing.status });
        } else {
          this.add(f);
        }
      });
      return ok(undefined);
    } catch (e) {
      return fail(new AppError('Failed to add scan findings', 'SYSTEM', { originalError: e }));
    }
  }

  getMsgByVendor(vendor: string): Vulnerability[] {
    return this.items.filter(v => v.vendor.toLowerCase() === vendor.toLowerCase());
  }

  getCriticalUnpatched(): Vulnerability[] {
    return this.items.filter(v => v.score >= 9.0 && v.status !== 'PATCHED');
  }
}
