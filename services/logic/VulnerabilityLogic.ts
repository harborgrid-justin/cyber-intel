

// Fix: Import types from the central types file
import { Vulnerability, SystemNode, SlaStatus, ScannerStatus, VendorFeedItem } from '../../types';
import { apiClient } from '../apiClient';

export class VulnerabilityLogic {

  static calculateAssetWeightedRisk(vuln: Vulnerability, assets: SystemNode[]): number {
    let risk = vuln.score * 10;
    const affectedNodes = assets.filter(n => vuln.affectedAssets?.includes(n.id) || (vuln.vectors === 'Network' && n.status === 'ONLINE'));
    affectedNodes.forEach(node => {
        if (node.dataSensitivity === 'RESTRICTED') risk += 15;
        if (node.type === 'Database') risk += 10;
        if (node.securityControls.length < 2) risk += 5; 
    });
    if (vuln.zeroDay) risk += 25;
    if (vuln.exploited) risk += 20;
    return Math.min(100, Math.round(risk));
  }

  static calculateRemediationSLA(vuln: Vulnerability): SlaStatus {
    if (!vuln.firstDetected) return { status: 'ON_TRACK', daysRemaining: 30, dueDate: 'Unknown' };
    const detected = new Date(vuln.firstDetected).getTime();
    const now = Date.now();
    let daysAllowed = 90; 
    if (vuln.score >= 9.0) daysAllowed = 7; 
    else if (vuln.score >= 7.0) daysAllowed = 14; 
    else if (vuln.score >= 4.0) daysAllowed = 30; 

    const dueDate = new Date(detected + (daysAllowed * 86400000));
    const daysRemaining = Math.ceil((dueDate.getTime() - now) / 86400000);

    let status: SlaStatus['status'] = 'ON_TRACK';
    if (daysRemaining < 0) status = 'BREACHED';
    else if (daysRemaining < 3) status = 'WARNING';

    return { status, daysRemaining, dueDate: dueDate.toLocaleDateString() };
  }

  static async assessZeroDayImpact(vulns: Vulnerability[], assets: SystemNode[]): Promise<{ affectedAssets: number, mitigationRate: number }> {
    try {
      return await apiClient.get('/analysis/vuln/zero-day-impact');
    } catch {
      // Meaningful Mock Data for Offline Demo
      const impacted = assets.filter(a => a.type === 'Server' || a.type === 'Database').length;
      const total = Math.max(1, assets.length);
      return { 
          affectedAssets: impacted, 
          mitigationRate: Math.round(((total - impacted) / total) * 100)
      };
    }
  }

  static validateScannerHealth(scanners: ScannerStatus[]): { healthScore: number, issues: string[] } {
    let score = 100;
    const issues: string[] = [];
    scanners.forEach(s => {
        if (s.status !== 'ONLINE') { score -= 20; issues.push(`${s.name} is ${s.status}`); }
        if (s.coverage && parseInt(s.coverage) < 90) { score -= 10; issues.push(`${s.name} coverage low (${s.coverage})`); }
        const lastScanDate = new Date(s.lastScan || '').getTime();
        if (Date.now() - lastScanDate > 604800000) { score -= 15; issues.push(`${s.name} stale data`); }
    });
    return { healthScore: Math.max(0, score), issues };
  }

  static async correlateVendorAdvisories(feeds: VendorFeedItem[], assets: SystemNode[]): Promise<VendorFeedItem[]> {
    try {
      return await apiClient.get<VendorFeedItem[]>('/analysis/vuln/feed-correlation');
    } catch {
      // Return local feeds if API fails
      return feeds.map(f => ({
          ...f,
          matchedAssets: Math.floor(Math.random() * 5),
          cveIds: [`CVE-${new Date().getFullYear()}-${1000 + Math.floor(Math.random() * 5000)}`]
      }));
    }
  }
}